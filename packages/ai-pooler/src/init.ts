/**
 * Rulecatch AI Pooler initialization
 * Interactive setup: API key validation, encryption, hook installation
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync, chmodSync, unlinkSync, copyFileSync, rmSync } from 'fs';
import { homedir } from 'os';
import { join, dirname } from 'path';
import { randomBytes } from 'crypto';
import { createInterface } from 'readline';
import { createRequire } from 'module';

const _require = createRequire(import.meta.url);
const PKG_VERSION: string = (_require('../package.json') as { version: string }).version;

// Paths
const CLAUDE_DIR = join(homedir(), '.claude');
const HOOKS_DIR = join(CLAUDE_DIR, 'hooks');
const RULECATCH_DIR = join(CLAUDE_DIR, 'rulecatch');
const CONFIG_PATH = join(RULECATCH_DIR, 'config.json');
const BUFFER_DIR = join(RULECATCH_DIR, 'buffer');
const SETTINGS_PATH = join(CLAUDE_DIR, 'settings.json');
const HOOK_SCRIPT_DEST = join(HOOKS_DIR, 'rulecatch-track.sh');
const FLUSH_SCRIPT_DEST = join(HOOKS_DIR, 'rulecatch-flush.js');
const MCP_SERVER_DEST = join(RULECATCH_DIR, 'mcp-server.js');

// Colors
const green = (s: string) => `\x1b[32m${s}\x1b[0m`;
const red = (s: string) => `\x1b[31m${s}\x1b[0m`;
const yellow = (s: string) => `\x1b[33m${s}\x1b[0m`;
const dim = (s: string) => `\x1b[2m${s}\x1b[0m`;

interface Config {
  apiKey: string;
  projectId: string;
  region: 'us' | 'eu';
  batchSize: number;
  salt: string;
  encryptionKey: string;
  autoGeneratedKey?: boolean;
  monitorOnly?: boolean;
}

interface ValidateResponse {
  valid: boolean;
  region?: 'us' | 'eu';
  plan?: string;
  daysRemaining?: number;
}

function prompt(question: string): Promise<string> {
  return new Promise((resolve) => {
    const rl = createInterface({ input: process.stdin, output: process.stdout });
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.trim());
    });
  });
}

function promptPassword(promptText: string): Promise<string> {
  return new Promise((resolve) => {
    const rl = createInterface({ input: process.stdin, output: process.stdout });

    if (process.stdin.isTTY) {
      process.stdin.setRawMode?.(true);
    }

    process.stdout.write(promptText);
    let password = '';

    const onData = (char: Buffer) => {
      const c = char.toString();
      if (c === '\n' || c === '\r') {
        process.stdin.removeListener('data', onData);
        if (process.stdin.isTTY) {
          process.stdin.setRawMode?.(false);
        }
        process.stdout.write('\n');
        rl.close();
        resolve(password);
      } else if (c === '\u0003') {
        process.exit(0);
      } else if (c === '\u007F' || c === '\b') {
        if (password.length > 0) {
          password = password.slice(0, -1);
          process.stdout.write('\b \b');
        }
      } else {
        password += c;
        process.stdout.write('*');
      }
    };

    process.stdin.on('data', onData);
    process.stdin.resume();
  });
}

async function validateApiKey(apiKey: string, region?: 'us' | 'eu'): Promise<ValidateResponse> {
  // Try the specified region first, then fall back to the other
  const regions: ('us' | 'eu')[] = region === 'eu' ? ['eu', 'us'] : ['us', 'eu'];

  for (const r of regions) {
    try {
      const baseUrl = r === 'eu' ? 'https://api-eu.rulecatch.ai' : 'https://api.rulecatch.ai';
      const response = await fetch(`${baseUrl}/api/v1/ai/validate-key`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ apiKey, clientVersion: PKG_VERSION }),
      });

      if (!response.ok) continue;

      const data = await response.json() as ValidateResponse;
      if (data.valid) return data;
    } catch {
      // This region unreachable, try next
    }
  }

  // Both regions failed or returned invalid
  return { valid: false };
}

function findFile(filename: string): string | null {
  const base = dirname(new URL(import.meta.url).pathname);
  const candidates = [
    join(base, '..', 'templates', filename),
    join(base, '..', '..', 'templates', filename),
    join(base, 'templates', filename),
  ];

  for (const c of candidates) {
    if (existsSync(c)) return c;
  }
  return null;
}

function findFlushScript(): string | null {
  const base = dirname(new URL(import.meta.url).pathname);
  const candidates = [
    join(base, 'flush.js'),
    join(base, '..', 'dist', 'flush.js'),
  ];

  for (const c of candidates) {
    if (existsSync(c)) return c;
  }
  return null;
}

function findMcpServer(): string | null {
  const base = dirname(new URL(import.meta.url).pathname);
  const candidates = [
    // Built MCP server (from packages/mcp-server/dist/)
    join(base, '..', '..', 'mcp-server', 'dist', 'index.js'),
    // Already installed
    join(RULECATCH_DIR, 'mcp-server.js'),
  ];

  for (const c of candidates) {
    if (existsSync(c)) return c;
  }
  return null;
}

export interface InitOptions {
  apiKey?: string;
  projectId?: string;
  region?: 'us' | 'eu';
  batchSize?: number;
  encryptionKey?: string;
  monitorOnly?: boolean;
}

export async function init(options: InitOptions = {}): Promise<void> {
  console.log('\nRulecatch AI Analytics Setup');
  console.log('----------------------------\n');

  // 0. Check if user has an account (skip if --monitor-only or --api-key)
  let monitorOnly = options.monitorOnly || false;

  if (!options.apiKey && !monitorOnly) {
    const hasAccount = await prompt(
      'Do you have a RuleCatch account?\n' +
      '  1) Yes, I have an API key\n' +
      '  2) No, I need to create an account\n' +
      '  3) No, just let me try the monitor first\n' +
      '> '
    );

    if (hasAccount === '3') {
      monitorOnly = true;
    } else if (hasAccount === '2' || hasAccount.toLowerCase().startsWith('n')) {
      console.log('\nOpening RuleCatch signup in your browser...');
      console.log('After creating an account, run this command again with your API key.\n');

      // Open browser to signup page
      const signupUrl = options.region === 'eu'
        ? 'https://dashboard-eu.rulecatch.ai/signup'
        : 'https://dashboard.rulecatch.ai/signup';
      try {
        const { exec } = await import('child_process');
        const platform = process.platform;

        if (platform === 'darwin') {
          exec(`open "${signupUrl}"`);
        } else if (platform === 'win32') {
          exec(`start "" "${signupUrl}"`);
        } else {
          // Linux and others
          exec(`xdg-open "${signupUrl}" 2>/dev/null || sensible-browser "${signupUrl}" 2>/dev/null || x-www-browser "${signupUrl}" 2>/dev/null || echo "Please open: ${signupUrl}"`);
        }

        console.log(`${dim('If browser didn\'t open, visit:')} ${signupUrl}\n`);
      } catch {
        console.log(`Visit: ${signupUrl}\n`);
      }

      process.exit(0);
    }
  }

  // Determine project ID (used in both monitor-only and full mode)
  let projectId = options.projectId || '';
  if (!projectId) {
    // Auto-detect from git repo name or cwd
    try {
      const { execSync } = await import('child_process');
      const remote = execSync('git remote get-url origin 2>/dev/null', { encoding: 'utf-8' }).trim();
      projectId = remote.split('/').pop()?.replace('.git', '') || '';
    } catch {
      // Not a git repo â€” use directory name
      projectId = process.cwd().split('/').pop() || 'default';
    }
  }

  // Monitor-only path: skip API key, encryption, validation
  if (monitorOnly) {
    const region = options.region || 'us';
    console.log(green('Monitor-only mode'));
    console.log(`Region: ${region === 'eu' ? 'EU (Frankfurt)' : 'US (Virginia)'}`);
    console.log(`Project: ${projectId}\n`);

    const config: Config = {
      apiKey: '',
      projectId,
      region,
      batchSize: options.batchSize || 20,
      salt: '',
      encryptionKey: '',
      monitorOnly: true,
    };

    // Create directory structure
    mkdirSync(RULECATCH_DIR, { recursive: true });
    mkdirSync(BUFFER_DIR, { recursive: true });
    mkdirSync(HOOKS_DIR, { recursive: true });

    // Write config
    writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2), { mode: 0o600 });
    console.log(green('+ Config saved to ~/.claude/rulecatch/config.json'));

    // Delete stale gate file so fresh check happens on first flush
    const gateFile = join(RULECATCH_DIR, '.monitor-gate');
    if (existsSync(gateFile)) {
      unlinkSync(gateFile);
    }

    // Copy hook script from template
    const hookTemplate = findFile('rulecatch-track.sh');
    if (hookTemplate) {
      copyFileSync(hookTemplate, HOOK_SCRIPT_DEST);
      chmodSync(HOOK_SCRIPT_DEST, 0o755);
      console.log(green('+ Hook script installed to ~/.claude/hooks/rulecatch-track.sh'));
    } else {
      console.log(yellow('! Hook script template not found. You may need to reinstall.'));
    }

    // Copy flush script
    const flushSource = findFlushScript();
    if (flushSource) {
      copyFileSync(flushSource, FLUSH_SCRIPT_DEST);
      chmodSync(FLUSH_SCRIPT_DEST, 0o755);
      console.log(green('+ Flush script installed to ~/.claude/hooks/rulecatch-flush.js'));
    } else {
      console.log(yellow('! Flush script not found. Run `pnpm build` first if developing locally.'));
    }

    // NO MCP server in monitor-only mode

    // Register hooks (no MCP)
    registerHooks(false);
    console.log(green('+ Hooks registered in ~/.claude/settings.json'));

    console.log(green('\n+ Monitor mode enabled!') + ' Hooks activate on your next Claude Code session.');
    console.log('  Run `npx @rulecatch/ai-pooler monitor` to see live AI activity.');
    console.log('  If Claude is running now, type /exit and reopen to activate.\n');
    return;
  }

  // 1. Get API key
  let apiKey = options.apiKey;
  if (!apiKey) {
    const dashUrl = options.region === 'eu' ? 'https://dashboard-eu.rulecatch.ai' : 'https://dashboard.rulecatch.ai';
    apiKey = await prompt(`Enter your API key (get one at ${dashUrl}):\n> `);
  }

  if (!apiKey || !apiKey.startsWith('dc_')) {
    console.log(red('\nInvalid API key. Keys start with "dc_".'));
    process.exit(1);
  }

  // 2. Validate API key
  process.stdout.write('Validating API key... ');
  const validation = await validateApiKey(apiKey, options.region);

  if (!validation.valid) {
    console.log(red('Invalid'));
    const errDashUrl = options.region === 'eu' ? 'https://dashboard-eu.rulecatch.ai' : 'https://dashboard.rulecatch.ai';
    console.log(red(`\nAPI key is not valid. Get a key at ${errDashUrl}\n`));
    process.exit(1);
  }

  const region = options.region || validation.region || 'us';
  const planInfo = validation.plan || 'unknown';
  const daysInfo = validation.daysRemaining && validation.daysRemaining > 0
    ? ` - ${validation.daysRemaining} days remaining`
    : '';

  console.log(green(`Valid (${planInfo}${daysInfo})`));
  console.log(`Region: ${region === 'eu' ? 'EU (Frankfurt)' : 'US (Virginia)'} - set in your dashboard account\n`);

  // 3. Get encryption password
  let encryptionPassword: string;
  let autoGeneratedKey = false;
  if (options.encryptionKey) {
    // Passed via --encryption-key flag (e.g. easy AI install mode)
    encryptionPassword = options.encryptionKey;
    if (encryptionPassword.length < 8) {
      console.log(red('\nEncryption key must be at least 8 characters.\n'));
      process.exit(1);
    }
    console.log(green('+ Encryption key set from --encryption-key flag'));
    console.log(dim("Use this same key in the dashboard to decrypt your personal data.\n"));
  } else if (process.stdin.isTTY) {
    encryptionPassword = await promptPassword('Enter an encryption password (used locally to encrypt PII before sending):\n> ');

    if (encryptionPassword.length < 8) {
      console.log(red('\nPassword must be at least 8 characters.\n'));
      process.exit(1);
    }

    console.log(dim("\nYou'll need this same password in the dashboard to decrypt your personal data.\n"));
  } else {
    encryptionPassword = randomBytes(32).toString('base64');
    autoGeneratedKey = true;
    console.log(dim('Non-interactive mode: auto-generated encryption password.'));
    console.log(dim('Retrieve it with: npx @rulecatch/ai-pooler config --show-key\n'));
  }

  // 5. Create config
  const salt = randomBytes(32).toString('base64');

  const config: Config = {
    apiKey,
    projectId,
    region,
    batchSize: options.batchSize || 20,
    salt,
    encryptionKey: encryptionPassword,
    ...(autoGeneratedKey && { autoGeneratedKey: true }),
  };

  // Delete stale monitor gate file when upgrading to full mode
  const gateFile = join(RULECATCH_DIR, '.monitor-gate');
  if (existsSync(gateFile)) {
    unlinkSync(gateFile);
  }

  // 5. Create directory structure
  mkdirSync(RULECATCH_DIR, { recursive: true });
  mkdirSync(BUFFER_DIR, { recursive: true });
  mkdirSync(HOOKS_DIR, { recursive: true });

  // 6. Write config
  writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2), { mode: 0o600 });
  console.log(green('+ Config saved to ~/.claude/rulecatch/config.json'));

  // 7. Copy hook script from template
  const hookTemplate = findFile('rulecatch-track.sh');
  if (hookTemplate) {
    copyFileSync(hookTemplate, HOOK_SCRIPT_DEST);
    chmodSync(HOOK_SCRIPT_DEST, 0o755);
    console.log(green('+ Hook script installed to ~/.claude/hooks/rulecatch-track.sh'));
  } else {
    console.log(yellow('! Hook script template not found. You may need to reinstall.'));
  }

  // 8. Copy flush script
  const flushSource = findFlushScript();
  if (flushSource) {
    copyFileSync(flushSource, FLUSH_SCRIPT_DEST);
    chmodSync(FLUSH_SCRIPT_DEST, 0o755);
    console.log(green('+ Flush script installed to ~/.claude/hooks/rulecatch-flush.js'));
  } else {
    console.log(yellow('! Flush script not found. Run `pnpm build` first if developing locally.'));
  }

  // 9. Copy MCP server
  const mcpServerSource = findMcpServer();
  if (mcpServerSource) {
    copyFileSync(mcpServerSource, MCP_SERVER_DEST);
    console.log(green('+ MCP server installed to ~/.claude/rulecatch/mcp-server.js'));
  } else {
    console.log(yellow('! MCP server not found. MCP tools will not be available.'));
  }

  // 10. Register hooks + MCP server in settings.json
  registerHooks(!!mcpServerSource);
  console.log(green('+ Hooks registered in ~/.claude/settings.json'));
  if (mcpServerSource) {
    console.log(green('+ MCP server registered in ~/.claude/settings.json'));
  }

  console.log(green('\n+ Setup complete!') + ' Hooks activate on your next Claude Code session.');
  console.log('  If Claude is running now, type /exit and reopen to activate.\n');
}

function registerHooks(includeMcpServer: boolean = false): void {
  let settings: Record<string, unknown> = {};
  if (existsSync(SETTINGS_PATH)) {
    try {
      settings = JSON.parse(readFileSync(SETTINGS_PATH, 'utf-8'));
    } catch {
      // Start fresh
    }
  }

  const asyncHook = {
    hooks: [{ type: 'command', command: HOOK_SCRIPT_DEST, timeout: 10, async: true }],
  };
  const syncHook = {
    hooks: [{ type: 'command', command: HOOK_SCRIPT_DEST, timeout: 30, async: false }],
  };
  const asyncToolHook = { matcher: '.*', ...asyncHook };

  settings.hooks = {
    // Session lifecycle
    SessionStart: [{ ...syncHook }],
    SessionEnd: [{ ...syncHook }],
    // User interaction
    UserPromptSubmit: [{ ...asyncHook }],
    // Tool lifecycle (all tools via .* matcher)
    PreToolUse: [{ ...asyncToolHook }],
    PostToolUse: [{ ...asyncToolHook }],
    PostToolUseFailure: [{ ...asyncToolHook }],
    PermissionRequest: [{ ...asyncToolHook }],
    // Notifications
    Notification: [{ matcher: '.*', ...asyncHook }],
    // Subagents
    SubagentStart: [{ matcher: '.*', ...asyncHook }],
    SubagentStop: [{ matcher: '.*', ...asyncHook }],
    // Turn lifecycle
    Stop: [{ ...asyncHook }],
    // Teams
    TeammateIdle: [{ ...asyncHook }],
    TaskCompleted: [{ ...asyncHook }],
    // Compaction
    PreCompact: [{ ...asyncHook }],
  };

  // Register MCP server so Claude Code can use Rulecatch tools
  if (includeMcpServer) {
    const mcpServers = (settings.mcpServers || {}) as Record<string, unknown>;
    mcpServers.rulecatch = {
      command: 'node',
      args: [MCP_SERVER_DEST],
    };
    settings.mcpServers = mcpServers;
  }

  // Remove old RULECATCH_*/DWELLCOUNT_* env vars (cleanup)
  if (settings.env && typeof settings.env === 'object') {
    const env = settings.env as Record<string, string>;
    for (const key of Object.keys(env)) {
      if (key.startsWith('RULECATCH_') || key.startsWith('DWELLCOUNT_')) {
        delete env[key];
      }
    }
    if (Object.keys(env).length === 0) {
      delete settings.env;
    }
  }

  writeFileSync(SETTINGS_PATH, JSON.stringify(settings, null, 2));
}

export function uninstall(): void {
  console.log('\nRemoving Rulecatch tracking...\n');

  // Remove hook script
  if (existsSync(HOOK_SCRIPT_DEST)) {
    unlinkSync(HOOK_SCRIPT_DEST);
    console.log(green('+ Removed hook script'));
  }

  // Remove flush script
  if (existsSync(FLUSH_SCRIPT_DEST)) {
    unlinkSync(FLUSH_SCRIPT_DEST);
    console.log(green('+ Removed flush script'));
  }

  // Remove old hook script name
  const oldHookPath = join(HOOKS_DIR, 'dwellcount-track.sh');
  if (existsSync(oldHookPath)) {
    unlinkSync(oldHookPath);
    console.log(green('+ Removed old hook script (dwellcount-track.sh)'));
  }

  // Remove entire rulecatch directory
  if (existsSync(RULECATCH_DIR)) {
    rmSync(RULECATCH_DIR, { recursive: true, force: true });
    console.log(green('+ Removed ~/.claude/rulecatch/ directory'));
  }

  // Remove old config files
  for (const oldFile of ['rulecatch.json', 'rulecatch-privacy.json', '.rulecatch-key']) {
    const p = join(CLAUDE_DIR, oldFile);
    if (existsSync(p)) {
      unlinkSync(p);
      console.log(green(`+ Removed old file: ${oldFile}`));
    }
  }

  // Clean settings.json
  if (existsSync(SETTINGS_PATH)) {
    try {
      const settings = JSON.parse(readFileSync(SETTINGS_PATH, 'utf-8'));
      delete settings.hooks;

      if (settings.env) {
        for (const key of Object.keys(settings.env)) {
          if (key.startsWith('RULECATCH_') || key.startsWith('DWELLCOUNT_')) {
            delete settings.env[key];
          }
        }
        if (Object.keys(settings.env).length === 0) {
          delete settings.env;
        }
      }

      writeFileSync(SETTINGS_PATH, JSON.stringify(settings, null, 2));
      console.log(green('+ Cleaned up settings.json'));
    } catch {
      console.log(yellow('! Could not update settings.json'));
    }
  }

  console.log(green('\n+ Rulecatch tracking removed.\n'));
}
